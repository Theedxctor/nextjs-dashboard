pnpm - this is the preferred package manager for next.js
npm install -g pnpm
npx create-next-app@latest 'file name' //Agree to use tailwind it autoinstalls the tailwind files.
pnpm i = to install the next.js config files
pnpm dev = to start the developmet server on localhost:3000

Layout.js is the root file
/app = Contains all the routes, components and logic for the application.
/app/lib = Contains functions used in the application, such as reusable utility functions and data fetching functions
/app/ui = Contains all the UI components for your application such as cards, tables and forms
/public = Contains all the static assets for your application, such as images and the favicon

Use tailwind, css to style the application
clsx - a library that lets you toggle class names easily.{https://github.com/lukeed/clsx}
import clsx from 'clsx';
 
export default function InvoiceStatus({ status }: { status: string }) {
  return (
    <span
      className={clsx(
        'inline-flex items-center rounded-full px-2 py-1 text-sm',
        {
          'bg-gray-100 text-gray-500': status === 'pending',
          'bg-green-500 text-white': status === 'paid',
        },
      )}
    >
    // ...
)}

next/font = module that allows NextJS to automatically optimize fonts in the application. It downloads font files at build time and hosts them with your other static assets. It therefore ensures no additional network requests for fonts which would impact performance.
import { Inter } from 'next/font/google';
export const inter = Inter({ subsets: ['latin'] });
Add the font to the body to apply{/app/layout.tsx}
import { inter } from '@/app/ui/fonts';
<body className={`${inter.className} antialiased`}>{children}</body>
antialiased class in tailwind smoothes out the font but not necessary.

next/image = automatically optimize your images
<Image> = Preventing layout shift automatically when images are loading.
        Resizing images to avoid shipping large images to devices with a smaller viewport.
        Lazy loading images by default (images load as they enter the viewport).
        Serving images in modern formats, like WebP and AVIF, when the browser supports it.
className="hidden md:block" this is to remove the image from the DOM on mobile screens and to show the image on desktop screens.

Nextjs uses file-system routing where folders are used to create nested routes. Each folder represents a route segment that maps to a URL segment.
using layout.tsx and page.tsx you can create separate UI's for each route.
page.tsx is a special Next.js file that exports a React component, and it's required for the route to be accessible.
layout.tsx allows creation of a UI such as a dashboard that is shared between multiple pages.

<SideNav /> = Any components you import into this file will be part of the layout.
The <Layout /> component receives a children prop. This child can either be a page or another layout.

The advantage of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render.

next/link = a component that wraps anchor tags to handle client-side navigation between routes.
<Link> = it is used in replace of <a> allows navigation between pages without doing a full refresh.
Automatic code-splitting = means that pages become isolated. If a certain page throws an error, the rest of the application still works.
In production, whenever <Link> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will be loaded in the background, this makes the page transition near-instant.

usePathname() = a react hook that Next.js can use to check the current path and implement showing an active link to indicate to the user what page they are currently on.
NB: Since usePathname() is a React hook, you'll need to turn nav-links.tsx into a Client Component. Add React's "use client" directive to the top of the file, then import usePathname() from next/navigation

How to fetch data;
1. API Layer = if you're using 3rd party services that provide an API
            if you're fetching data from the client, to avoid exposing your database secrets to the client

2. Database queries = when creating API endpoints, you need to write logic to interact with your database.
            if you're using react server components, you can skip the API layer, and query your database directly without risking exposing your database secrets to the client.

By default, Next.js applications use React Server Components.
i)Server Components support JavaScript Promises, providing a solution for asynchronous tasks like data fetching natively. You can use async/await syntax without needing useEffect, useState or other data fetching libraries.
ii) Server Components run on the server, so you can keep expensive data fetches and logic on the server, only sending the result to the client.
iii) Since Server Components run on the server, you can query the database directly without an additional API layer. This saves you from writing and maintaining additional code.

Waterfall = refers to a sequence of network requests that depend on the completion of previous requests.
In the case of data fetching, each request can only begin once the previous request has returned data.
Parallel data fetching = a common way to avoid waterfalls.
By using this pattern, you can:
Start executing all data fetches at the same time, which is faster than waiting for each request to complete in a waterfall.
Use a native JavaScript pattern that can be applied to any library or framework.
However, there is one disadvantage of relying only on this JavaScript pattern: what happens if one data request is slower than all the others ? Your application is only as fast as your slowest data fetch. It delays loading the UI to the visitor until the data is fetched.

Static rendering = data fetching and rendering happens on the server at build time or when revalidating data.
Benefits of static rendering: Faster websites, Reduced Server Load, Better SEO
Dynamic rendering = content is rendered on the server for each user at request time (when the user visits the page). 
Benefits of dynamic rendering: Real-Time Data, User-Specific Content, Request Time Information

Streaming = data transfer technique that allows you to break down a route into smaller "chunks" and progressively stream them from the server to the client as they become ready.
It prevents slow data requests from blocking your whole page.
There are two ways you implement streaming in Next.js:
At the page level, with the loading.tsx file (which creates <Suspense> for you).
At the component level, with <Suspense> for more granular control.

loading.tsx = a nextjs file built on top of React Suspensee. It allows you to create fallback UI to show as a replacement while page content loads.
Since <SideNav> is static, it is shown immediately. The user can interact with it while the dynamic content is loading. They don't have to wait for the page to finish loading before navigating away(this is called interruptable navigation)
Loading skeletons = simplified versions of the UI.

Route groups allow you to organize files into logical groups withouut affecting the URL path structure. When you create a new folder using (), the name won't be included in the URL path. So /dashboard/(overview)/page.tsx becomes /dashboard

Suspense allows you to defer rendering parts of your application until some condition is met (e.g. data is loaded). You can wrap your dynamic components in Suspense. Then, pass it a fallback component to show while the dynamic component loads.

Grouping Components = You can fetch data for each individual card, but this could lead to a popping effect as the cards load in, this can be visually jarring for the user.
So, how would you tackle this problem?
To create more of a staggered effect, you can group the cards using a wrapper component. This means the static <SideNav/> will be shown first, followed by the cards, etc.

Where you place your Suspense boundaries will depend on a few things:
How you want the user to experience the page as it streams.
What content you want to prioritize.
If the components rely on data fetching.
By moving data fetching down to the components that need it, you can create more granular Suspense boundaries. This allows you to stream specific components and prevent the UI from blocking.





pnpm - this is the preferred package manager for next.js
npm install -g pnpm
npx create-next-app@latest 'file name' //Agree to use tailwind it autoinstalls the tailwind files.
pnpm i = to install the next.js config files
pnpm dev = to start the developmet server on localhost:3000

Layout.js is the root file
/app = Contains all the routes, components and logic for the application.
/app/lib = Contains functions used in the application, such as reusable utility functions and data fetching functions
/app/ui = Contains all the UI components for your application such as cards, tables and forms
/public = Contains all the static assets for your application, such as images and the favicon

Use tailwind, css to style the application
Tailwind is a CSS framework that speeds up the development process by allowing you to quickly write utility classes directly in your React code.
In Tailwind, you style elements by adding class names. For example, adding "text-blue-500" will turn the <h1> text blue:
global.css - You can use this file to add CSS rules to all the routes in your application - such as CSS reset rules, site-wide styles for HTML elements like links, and more.

You can import global.css in any component in your application, but it's usually good practice to add it to your top-level component
clsx - a library that lets you toggle class names easily.{https://github.com/lukeed/clsx}
import clsx from 'clsx';
 
export default function InvoiceStatus({ status }: { status: string }) {
  return (
    <span
      className={clsx(
        'inline-flex items-center rounded-full px-2 py-1 text-sm',
        {
          'bg-gray-100 text-gray-500': status === 'pending',
          'bg-green-500 text-white': status === 'paid',
        },
      )}
    >
    // ...
)}

next/font = module that allows NextJS to automatically optimize fonts in the application. 
It downloads font files at build time and hosts them with your other static assets. 
It therefore ensures no additional network requests for fonts which would impact performance.

import { Inter } from 'next/font/google';
export const inter = Inter({ subsets: ['latin'] });
Add the font to the body to apply{/app/layout.tsx}
import { inter } from '@/app/ui/fonts';
<body className={`${inter.className} antialiased`}>{children}</body>
antialiased class in tailwind smoothes out the font but not necessary.

next/image = automatically optimize your images
<Image> = Preventing layout shift automatically when images are loading.
        Resizing images to avoid shipping large images to devices with a smaller viewport.
        Lazy loading images by default (images load as they enter the viewport).
        Serving images in modern formats, like WebP and AVIF, when the browser supports it.
className="hidden md:block" this is to remove the image from the DOM on mobile screens and to show the image on desktop screens.
you're setting the width to 1000 and height to 760 pixels. 
It's good practice to set the width and height of your images to avoid layout shift, these should be an aspect ratio identical to the source image. 
These values are not the size the image is rendered, but instead the size of the actual image file used to understand the aspect ratio.

Nextjs uses file-system routing where folders are used to create nested routes. Each folder represents a route segment that maps to a URL segment.
using layout.tsx and page.tsx you can create separate UI's for each route.
page.tsx is a special Next.js file that exports a React component, and it's required for the route to be accessible.
layout.tsx allows creation of a UI such as a dashboard that is shared between multiple pages.

<SideNav /> = Any components you import into this file will be part of the layout.
The <Layout /> component receives a children prop. This child can either be a page or another layout.

The advantage of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render.
the root layout is required in every Next.js application. Any UI you add to the root layout will be shared across all pages in your application

next/link = a component that wraps anchor tags to handle client-side navigation between routes with JavaScript.
<Link> = it is used in replace of <a> allows navigation between pages without doing a full refresh.
Automatic code-splitting = means that pages become isolated. If a certain page throws an error, the rest of the application still works.
In production, whenever <Link> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will be loaded in the background, this makes the page transition near-instant.

usePathname() = a react hook that Next.js can use to check the current path and implement showing an active link to indicate to the user what page they are currently on.
NB: Since usePathname() is a React hook, you'll need to turn nav-links.tsx into a Client Component. Add React's "use client" directive to the top of the file, then import usePathname() from next/navigation
'use client' this means you can use event listeners and hooks.
How to fetch data;
1. API Layer = if you're using 3rd party services that provide an API
            if you're fetching data from the client, to avoid exposing your database secrets to the client

2. Database queries = when creating API endpoints, you need to write logic to interact with your database.
            if you're using react server components, you can skip the API layer, and query your database directly without risking exposing your database secrets to the client.

By default, Next.js applications use React Server Components.
i)Server Components support JavaScript Promises, providing a solution for asynchronous tasks like data fetching natively. You can use async/await syntax without needing useEffect, useState or other data fetching libraries.
ii) Server Components run on the server, so you can keep expensive data fetches and logic on the server, only sending the result to the client.
iii) Since Server Components run on the server, you can query the database directly without an additional API layer. This saves you from writing and maintaining additional code.

Waterfall = refers to a sequence of network requests that depend on the completion of previous requests.
In the case of data fetching, each request can only begin once the previous request has returned data.
Parallel data fetching = a common way to avoid waterfalls.
By using this pattern, you can:
Start executing all data fetches at the same time, which is faster than waiting for each request to complete in a waterfall.
Use a native JavaScript pattern that can be applied to any library or framework.
However, there is one disadvantage of relying only on this JavaScript pattern: what happens if one data request is slower than all the others ? Your application is only as fast as your slowest data fetch. It delays loading the UI to the visitor until the data is fetched.

Static rendering = data fetching and rendering happens on the server at build time or when revalidating data.
Benefits of static rendering: Faster websites, Reduced Server Load, Better SEO
Dynamic rendering = content is rendered on the server for each user at request time (when the user visits the page). 
Benefits of dynamic rendering: Real-Time Data, User-Specific Content, Request Time Information

Streaming = data transfer technique that allows you to break down a route into smaller "chunks" and progressively stream them from the server to the client as they become ready.
It prevents slow data requests from blocking your whole page.
There are two ways you implement streaming in Next.js:
At the page level, with the loading.tsx file (which creates <Suspense> for you).
At the component level, with <Suspense> for more granular control.

loading.tsx = a nextjs file built on top of React Suspensee. It allows you to create fallback UI to show as a replacement while page content loads.
Since <SideNav> is static, it is shown immediately. The user can interact with it while the dynamic content is loading. They don't have to wait for the page to finish loading before navigating away(this is called interruptable navigation)
Loading skeletons = simplified versions of the UI.

Route groups allow you to organize files into logical groups withouut affecting the URL path structure. When you create a new folder using (), the name won't be included in the URL path. So /dashboard/(overview)/page.tsx becomes /dashboard

Suspense allows you to defer rendering parts of your application until some condition is met (e.g. data is loaded). You can wrap your dynamic components in Suspense. Then, pass it a fallback component to show while the dynamic component loads.

Grouping Components = You can fetch data for each individual card, but this could lead to a popping effect as the cards load in, this can be visually jarring for the user.
So, how would you tackle this problem?
To create more of a staggered effect, you can group the cards using a wrapper component. This means the static <SideNav/> will be shown first, followed by the cards, etc.

Where you place your Suspense boundaries will depend on a few things:
How you want the user to experience the page as it streams.
What content you want to prioritize.
If the components rely on data fetching.
By moving data fetching down to the components that need it, you can create more granular Suspense boundaries. This allows you to stream specific components and prevent the UI from blocking.

Why use URL search params? 
It is used to manage the search state.
The benefits :
i) Bookmarkable and shareable URLs
ii) Server-sid rendering
iii) Analytics and tracking

useSearchParams = a Web Api that allows you to access the parameters of the current URL
usePathname = a Web Api that lets you read the current URL's pathname.
useRouter = a Web Api that enables navigation between routes within client components programmatically.

implementation steps:
1. Capture the user's input
2. Update the URL with the search params
3. Keep the URL in sync with the input field
4. Update the table to reflect the search query

defaultValue vs. value / Controlled vs. Uncontrolled

If you're using state to manage the value of an input, you'd use the value attribute to make it a controlled component. This means React would manage the input's state.
However, since you're not using state, you can use defaultValue. This means the native input will manage its own state. This is okay since you're saving the search query to the URL instead of state.

Debouncing = it limits the rate at which a function can fire. In our case, you only want to query the database when the user has stopped typing.
useDebounce

Pagination = allows the users to navigate through different pages to view all the invoices.

Server Actions = allow you to run async code directly on the server.
They eliminate the need to create API endpoints to mutate your data.Instead, you write asynchronous functions that execute on the server and can be invoked from your client or server components.
They include features like encrypted closures, strict input checks, error message hashing, host restrictions, and more â€” all working together to significantly enhance your application security.
An advantage of invoking a Server Action within a Server Component is progressive enhancement - forms work even if JavaScript has not yet loaded on the client. For example, without slower internet connections.
Server Actions are also deeply integrated with Next.js caching. When a form is submitted through a Server Action, not only can you use the action to mutate data, but you can also revalidate the associated cache using APIs like revalidatePath and revalidateTag.

Creating an Invoice
1. Create a form to capture the user's input
2. Create a server action and invoke it from the form
3. Inside your server action, extract the data from the formData object.
4. Validate and prepare the data to be inserted into your database.
5. Insert the data and handle any errors
6. Revalidate the cache and redirect the user back to invoices page.

By adding the 'use server', you mark all the exported functions within the file as Server Actions. These server functions can then be imported and used in Client and Server components. Any functions included in this file that are not used will be automatically removed from the final application bundle.
Good to know: In HTML, you'd pass a URL to the action attribute. This URL would be the destination where your form data should be submitted (usually an API endpoint).
However, in React, the action attribute is considered a special prop - meaning React builds on top of it to allow actions to be invoked.
Behind the scenes, Server Actions create a POST API endpoint. This is why you don't need to create API endpoints manually when using Server Actions.

To handle type validation, you have a few options. While you can manually validate types, using a type validation library can save you time and effort. For your example, we'll use Zod, a TypeScript-first validation library that can simplify this task for you.
It's usually good practice to store monetary values in cents in your database to eliminate JavaScript floating-point errors and ensure greater accuracy.

Updating an Invoice
1. Create a new dynamic route segment with the invoice id.
2. Read the invoice id from the page params.
3. Fetch the specific invoice from your database.
4. Pre-populate the form with the invoice data.
5. Update the invoice data in your database.

Next.js allows you to create Dynamic Route Segments when you don't know the exact segment name and want to create routes based on data. This could be blog post titles, product pages, etc. 

UUIDs vs. Auto-incrementing Keys

We use UUIDs instead of incrementing keys (e.g., 1, 2, 3, etc.). This makes the URL longer; however, UUIDs eliminate the risk of ID collision, are globally unique, and reduce the risk of enumeration attacks - making them ideal for large databases.

However, if you prefer cleaner URLs, you might prefer to use auto-incrementing keys.
Note: Using a hidden input field in your form also works (e.g. <input type="hidden" name="id" value={invoice.id} />). However, the values will appear as full text in the HTML source, which is not ideal for sensitive data.

There are a few things you'll notice about the code above:

"use client" - error.tsx needs to be a Client Component.
It accepts two props:
error: This object is an instance of JavaScript's native Error object.
reset: This is a function to reset the error boundary. When executed, the function will try to re-render the route segment.

Another way you can handle errors gracefully is by using the notFound function. While error.tsx is useful for catching uncaught exceptions, notFound can be used when you try to fetch a resource that doesn't exist.

Accessibility = designing and implementing web applications that everyone can use, including those with disabilities.

NextJS's ESLint configuration includes the eslint-plugin-jsx-ally plugin which helps catch accessibility issues early. 
pnpm add -D eslint eslint-config-next
pnpm lint 
While adding and configuring a linter is not a required step, it can be helpful to catch accessibility issues in your development process.

Improving form accessibility:
i) Semantic HTML
ii) Labelling
iii) Focus Outline

Form Validation
i) Client-side validation
ii) Server-side validation

In the code above, you're also adding the following aria labels:

aria-describedby="customer-error": This establishes a relationship between the select element and the error message container. It indicates that the container with id="customer-error" describes the select element. Screen readers will read this description when the user interacts with the select box to notify them of errors.
id="customer-error": This id attribute uniquely identifies the HTML element that holds the error message for the select input. This is necessary for aria-describedby to establish the relationship.
aria-live="polite": The screen reader should politely notify the user when the error inside the div is updated. When the content changes (e.g. when a user corrects an error), the screen reader will announce these changes, but only when the user is idle so as not to interrupt them.

AUTHENTICATION
It is how a system checks if the user is who they say they are.
Authorization determines what a user can access.
NextAuth.js is used to add authentication to the applciation.
pnpm i next-auth@beta

The {authorized} callback is used to verify if thhe requeest is authorized to access a page with Next.js Proxy.It is called before a request is completed, and it receives an object with the auth and request properties. The auth property contains the user's session, and the request property contains the incoming request.

The {unauthorized} callback is used to handle unauthorized requests. It is called when a request is not authorized, and it receives an object with the auth and request properties. The auth property contains the user's session, and the request property contains the incoming request.
The {providers} option is an array where you list different login options. For now, it's an empty array to satisfy NextAuth config. You'll learn more about it in the Adding the Credentials provider section.


The advantage of employing Proxy for this task is that the protected routes will not even start rendering until the Proxy verifies the authentication, enhancing both the security and performance of your application.

Password Hashing - converts a password into a fixed-length string of characters, which appears random, providing a layer of security even if the user's data is exposed.
bcrypt - to hash the user's password before storing it in the databas. You will use it again later to compare that the password entered by the user matches the one in the database.

Good to know:

There are other alternative providers such as OAuth or email. See the NextAuth.js docs for a full list of options.

MetaDATA
- In web development, metadata provides additional details about a webpage. Metadata is not visible to the users visiting the page. Instead, it works behind the scenes, embedded within the page's HTML, usually within the <head> element. This hidden information is crucial for search engines and other systems that need to understand your webpage's content better.
- It plays an important role in enhancing a webpage's SEO, making it more accessible and understandable for search engines and social media platforms.
- Proper metadata helps search engines effectively index webpages, improving their ranking in search results. Additionally, metadata like Open Graph improves the appearance of shared links on social media, making the content more appealing and informative for users.

<meta name="keywords" content="keyword1, keyword2, keyword3" /> = Keyword Metadata: This metadata includes the keywords related to the webpage content, helping search engines index the page.
Open Graph Metadata: This metadata enhances the way a webpage is represented when shared on social media platforms, providing information such as the title, description, and preview image.
<meta property="og:title" content="Title Here" />
<meta property="og:description" content="Description Here" />
<meta property="og:image" content="image_url_here" />
Favicon Metadata: This metadata links the favicon (a small icon) to the webpage, displayed in the browser's address bar or tab.
<link rel="icon" href="path/to/favicon.ico" />

Config-based: Export a static metadata object or a dynamic generateMetadata function in a layout.js or page.js file.
File-based: Next.js has a range of special files that are specifically used for metadata purposes:
favicon.ico, apple-icon.jpg, and icon.jpg: Utilized for favicons and icons
opengraph-image.jpg and twitter-image.jpg: Employed for social media images
robots.txt: Provides instructions for search engine crawling
sitemap.xml: Offers information about the website's structure

Page title and descriptions
You can also include a metadata object from any layout.js or page.js file to add additional page information like title and description. Any metadata in layout.js will be inherited by all pages that use it.
Next.js will automatically add the title and metadata to your application.

But what if you want to add a custom title for a specific page? You can do this by adding a metadata object to the page itself. Metadata in nested pages will override the metadata in the parent.
For example, in the /dashboard/invoices page, you can update the page title:

/app/dashboard/invoices/page.tsx
import { Metadata } from 'next';
 
export const metadata: Metadata = {
  title: 'Invoices | Acme Dashboard',
};
This works, but we are repeating the title of the application in every page. If something changes, like the company name, you'd have to update it on every page.

Instead, you can use the title.template field in the metadata object to define a template for your page titles. This template can include the page title, and any other information you want to include.

In your root layout, update the metadata object to include a template:

/app/layout.tsx
import { Metadata } from 'next';
 
export const metadata: Metadata = {
  title: {
    template: '%s | Acme Dashboard',
    default: 'Acme Dashboard',
  },
  description: 'The official Next.js Learn Dashboard built with App Router.',
  metadataBase: new URL('https://next-learn-dashboard.vercel.sh'),
};
The %s in the template will be replaced with the specific page title.

Now, in your /dashboard/invoices page, you can add the page title:

/app/dashboard/invoices/page.tsx
export const metadata: Metadata = {
  title: 'Invoices',
};
Navigate to the /dashboard/invoices page and check the <head> element. You should see the page title is now Invoices | Acme Dashboard.


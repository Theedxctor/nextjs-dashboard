pnpm - this is the preferred package manager for next.js
npm install -g pnpm
npx create-next-app@latest 'file name' //Agree to use tailwind it autoinstalls the tailwind files.
pnpm i = to install the next.js config files
pnpm dev = to start the developmet server on localhost:3000

Layout.js is the root file
/app = Contains all the routes, components and logic for the application.
/app/lib = Contains functions used in the application, such as reusable utility functions and data fetching functions
/app/ui = Contains all the UI components for your application such as cards, tables and forms
/public = Contains all the static assets for your application, such as images and the favicon

Use tailwind, css to style the application
clsx - a library that lets you toggle class names easily.{https://github.com/lukeed/clsx}
import clsx from 'clsx';
 
export default function InvoiceStatus({ status }: { status: string }) {
  return (
    <span
      className={clsx(
        'inline-flex items-center rounded-full px-2 py-1 text-sm',
        {
          'bg-gray-100 text-gray-500': status === 'pending',
          'bg-green-500 text-white': status === 'paid',
        },
      )}
    >
    // ...
)}

next/font = module that allows NextJS to automatically optimize fonts in the application. It downloads font files at build time and hosts them with your other static assets. It therefore ensures no additional network requests for fonts which would impact performance.
import { Inter } from 'next/font/google';
export const inter = Inter({ subsets: ['latin'] });
Add the font to the body to apply{/app/layout.tsx}
import { inter } from '@/app/ui/fonts';
<body className={`${inter.className} antialiased`}>{children}</body>
antialiased class in tailwind smoothes out the font but not necessary.

next/image = automatically optimize your images
<Image> = Preventing layout shift automatically when images are loading.
        Resizing images to avoid shipping large images to devices with a smaller viewport.
        Lazy loading images by default (images load as they enter the viewport).
        Serving images in modern formats, like WebP and AVIF, when the browser supports it.
className="hidden md:block" this is to remove the image from the DOM on mobile screens and to show the image on desktop screens.

Nextjs uses file-system routing where folders are used to create nested routes. Each folder represents a route segment that maps to a URL segment.
using layout.tsx and page.tsx you can create separate UI's for each route.
page.tsx is a special Next.js file that exports a React component, and it's required for the route to be accessible.
layout.tsx allows creation of a UI such as a dashboard that is shared between multiple pages.

<SideNav /> = Any components you import into this file will be part of the layout.
The <Layout /> component receives a children prop. This child can either be a page or another layout.

The advantage of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render.

next/link = a component that wraps anchor tags to handle client-side navigation between routes.
<Link> = it is used in replace of <a> allows navigation between pages without doing a full refresh.
Automatic code-splitting = means that pages become isolated. If a certain page throws an error, the rest of the application still works.
In production, whenever <Link> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background. By the time the user clicks the link, the code for the destination page will be loaded in the background, this makes the page transition near-instant.

usePathname() = a react hook that Next.js can use to check the current path and implement showing an active link to indicate to the user what page they are currently on.
NB: Since usePathname() is a React hook, you'll need to turn nav-links.tsx into a Client Component. Add React's "use client" directive to the top of the file, then import usePathname() from next/navigation
'use client' this means you can use event listeners and hooks.
How to fetch data;
1. API Layer = if you're using 3rd party services that provide an API
            if you're fetching data from the client, to avoid exposing your database secrets to the client

2. Database queries = when creating API endpoints, you need to write logic to interact with your database.
            if you're using react server components, you can skip the API layer, and query your database directly without risking exposing your database secrets to the client.

By default, Next.js applications use React Server Components.
i)Server Components support JavaScript Promises, providing a solution for asynchronous tasks like data fetching natively. You can use async/await syntax without needing useEffect, useState or other data fetching libraries.
ii) Server Components run on the server, so you can keep expensive data fetches and logic on the server, only sending the result to the client.
iii) Since Server Components run on the server, you can query the database directly without an additional API layer. This saves you from writing and maintaining additional code.

Waterfall = refers to a sequence of network requests that depend on the completion of previous requests.
In the case of data fetching, each request can only begin once the previous request has returned data.
Parallel data fetching = a common way to avoid waterfalls.
By using this pattern, you can:
Start executing all data fetches at the same time, which is faster than waiting for each request to complete in a waterfall.
Use a native JavaScript pattern that can be applied to any library or framework.
However, there is one disadvantage of relying only on this JavaScript pattern: what happens if one data request is slower than all the others ? Your application is only as fast as your slowest data fetch. It delays loading the UI to the visitor until the data is fetched.

Static rendering = data fetching and rendering happens on the server at build time or when revalidating data.
Benefits of static rendering: Faster websites, Reduced Server Load, Better SEO
Dynamic rendering = content is rendered on the server for each user at request time (when the user visits the page). 
Benefits of dynamic rendering: Real-Time Data, User-Specific Content, Request Time Information

Streaming = data transfer technique that allows you to break down a route into smaller "chunks" and progressively stream them from the server to the client as they become ready.
It prevents slow data requests from blocking your whole page.
There are two ways you implement streaming in Next.js:
At the page level, with the loading.tsx file (which creates <Suspense> for you).
At the component level, with <Suspense> for more granular control.

loading.tsx = a nextjs file built on top of React Suspensee. It allows you to create fallback UI to show as a replacement while page content loads.
Since <SideNav> is static, it is shown immediately. The user can interact with it while the dynamic content is loading. They don't have to wait for the page to finish loading before navigating away(this is called interruptable navigation)
Loading skeletons = simplified versions of the UI.

Route groups allow you to organize files into logical groups withouut affecting the URL path structure. When you create a new folder using (), the name won't be included in the URL path. So /dashboard/(overview)/page.tsx becomes /dashboard

Suspense allows you to defer rendering parts of your application until some condition is met (e.g. data is loaded). You can wrap your dynamic components in Suspense. Then, pass it a fallback component to show while the dynamic component loads.

Grouping Components = You can fetch data for each individual card, but this could lead to a popping effect as the cards load in, this can be visually jarring for the user.
So, how would you tackle this problem?
To create more of a staggered effect, you can group the cards using a wrapper component. This means the static <SideNav/> will be shown first, followed by the cards, etc.

Where you place your Suspense boundaries will depend on a few things:
How you want the user to experience the page as it streams.
What content you want to prioritize.
If the components rely on data fetching.
By moving data fetching down to the components that need it, you can create more granular Suspense boundaries. This allows you to stream specific components and prevent the UI from blocking.

Why use URL search params? 
It is used to manage the search state.
The benefits :
i) Bookmarkable and shareable URLs
ii) Server-sid rendering
iii) Analytics and tracking

useSearchParams = a Web Api that allows you to access the parameters of the current URL
usePathname = a Web Api that lets you read the current URL's pathname.
useRouter = a Web Api that enables navigation between routes within client components programmatically.

implementation steps:
1. Capture the user's input
2. Update the URL with the search params
3. Keep the URL in sync with the input field
4. Update the table to reflect the search query

defaultValue vs. value / Controlled vs. Uncontrolled

If you're using state to manage the value of an input, you'd use the value attribute to make it a controlled component. This means React would manage the input's state.
However, since you're not using state, you can use defaultValue. This means the native input will manage its own state. This is okay since you're saving the search query to the URL instead of state.

Debouncing = it limits the rate at which a function can fire. In our case, you only want to query the database when the user has stopped typing.
useDebounce

Pagination = allows the users to navigate through different pages to view all the invoices.

Server Actions = allow you to run async code directly on the server.
They eliminate the need to create API endpoints to mutate your data.Instead, you write asynchronous functions that execute on the server and can be invoked from your client or server components.
They include features like encrypted closures, strict input checks, error message hashing, host restrictions, and more â€” all working together to significantly enhance your application security.
An advantage of invoking a Server Action within a Server Component is progressive enhancement - forms work even if JavaScript has not yet loaded on the client. For example, without slower internet connections.
Server Actions are also deeply integrated with Next.js caching. When a form is submitted through a Server Action, not only can you use the action to mutate data, but you can also revalidate the associated cache using APIs like revalidatePath and revalidateTag.

Creating an Invoice
1. Create a form to capture the user's input
2. Create a server action and invoke it from the form
3. Inside your server action, extract the data from the formData object.
4. Validate and prepare the data to be inserted into your database.
5. Insert the data and handle any errors
6. Revalidate the cache and redirect the user back to invoices page.

By adding the 'use server', you mark all the exported functions within the file as Server Actions. These server functions can then be imported and used in Client and Server components. Any functions included in this file that are not used will be automatically removed from the final application bundle.
Good to know: In HTML, you'd pass a URL to the action attribute. This URL would be the destination where your form data should be submitted (usually an API endpoint).
However, in React, the action attribute is considered a special prop - meaning React builds on top of it to allow actions to be invoked.
Behind the scenes, Server Actions create a POST API endpoint. This is why you don't need to create API endpoints manually when using Server Actions.

To handle type validation, you have a few options. While you can manually validate types, using a type validation library can save you time and effort. For your example, we'll use Zod, a TypeScript-first validation library that can simplify this task for you.
It's usually good practice to store monetary values in cents in your database to eliminate JavaScript floating-point errors and ensure greater accuracy.

Updating an Invoice
1. Create a new dynamic route segment with the invoice id.
2. Read the invoice id from the page params.
3. Fetch the specific invoice from your database.
4. Pre-populate the form with the invoice data.
5. Update the invoice data in your database.

Next.js allows you to create Dynamic Route Segments when you don't know the exact segment name and want to create routes based on data. This could be blog post titles, product pages, etc. 

UUIDs vs. Auto-incrementing Keys

We use UUIDs instead of incrementing keys (e.g., 1, 2, 3, etc.). This makes the URL longer; however, UUIDs eliminate the risk of ID collision, are globally unique, and reduce the risk of enumeration attacks - making them ideal for large databases.

However, if you prefer cleaner URLs, you might prefer to use auto-incrementing keys.
Note: Using a hidden input field in your form also works (e.g. <input type="hidden" name="id" value={invoice.id} />). However, the values will appear as full text in the HTML source, which is not ideal for sensitive data.

There are a few things you'll notice about the code above:

"use client" - error.tsx needs to be a Client Component.
It accepts two props:
error: This object is an instance of JavaScript's native Error object.
reset: This is a function to reset the error boundary. When executed, the function will try to re-render the route segment.

Another way you can handle errors gracefully is by using the notFound function. While error.tsx is useful for catching uncaught exceptions, notFound can be used when you try to fetch a resource that doesn't exist.












